eimport HTTP
import Vapor
import Foundation
import MeowVapor

<%
// Selects all classes and structs that are either based on a model or embeddable protocol
let classes = (types.classes.based["Model"] ?? []) + (types.classes.based["Embeddable"] ?? [])
let structs = (types.structs.based["Model"] ?? []) + (types.structs.based["Embeddable"] ?? [])
let serializables = classes + structs

let supportedPrimitives = ["ObjectId", "String", "Int", "Int32", "Bool", "Document", "Double", "Data", "Binary", "Date", "RegularExpression"]
%>

<%
for primitive in supportedPrimitives {
%>

extension Array where Element == <%= primitive %> {
init?(_ primitive: Primitive?) {
guard let doc = Document(primitive) else {
return nil
}

let schrodingerSelf = try? doc.arrayValue.map { primitive in
return try Meow.Helpers.requireValue(<%= primitive %>(primitive), keyForError: "")
}

guard let me = schrodingerSelf else {
return nil
}

self = me
}
}
<%
}
%>

<%
// Keeps track of all used types so they don't occur twice, workaround for a Sourcery bug
var usedNames = [String]()
%>

<%
// Selects all enums that are embeddable and generates a ype safe query for them, as well as it's conversion to a BSONValue
for type in types.enums where type.based["Embeddable"] != nil && type.rawTypeName != nil && supportedPrimitives.contains(type.rawTypeName!.name) {
%>
extension <%= type.name %> : ConcreteSingleValueSerializable {
<%
// Creates this type from a BSON Primitive
%>
init(value: Primitive?) throws {
let value = try Meow.Helpers.requireValue(value, keyForError: "")
let primitiveValue: <%= type.rawTypeName! %> = try Meow.Helpers.requireValue(<%= type.rawTypeName! %>(value), keyForError: "")
let me: <%= type.name %> = try Meow.Helpers.requireValue(<%= type.name %>(rawValue: primitiveValue), keyForError: "")

self = me
}

<%
// Serializes this enum case to a BSON type
%>
func meowSerialize() -> Primitive {
return self.rawValue
}

<%
// Serializes this enum case to a BSON type
%>
func meowSerialize(resolvingReferences: Bool = false) throws -> Primitive {
return self.rawValue
}

<%
// Generates a type safe query object for this enum type
%>
struct VirtualInstance {
<%
// Compares this enum's VirtualInstance type with an actual enum case and generates a Query
%>
static func ==(lhs: VirtualInstance, rhs: <%= type.name %>) -> Query {
return lhs.keyPrefix == rhs.meowSerialize()
}

var keyPrefix: String

init(keyPrefix: String = "") {
self.keyPrefix = keyPrefix
}
}
}
<% } %>

<%
// Loops over all serializable objects and creates an extension to ConcreteSerializable for each one
// ConcreteSerializable allows serializing to and from a BSON Document with this type
for type in serializables {
%>
extension <%= type.name %> : ConcreteSerializable {
func meowSerialize() -> Document {
return (try? self.meowSerialize(resolvingReferences: false) ) ?? Document()
}

func meowSerialize(resolvingReferences: Bool) throws -> Document {
<%
// Add the _id for models
if type.based["Model"] != nil {
%>
var doc: Document = ["_id": self.id]
<% } else { %>
var doc = Document()
<% } %>

<%
// If this is a DynamicSerializable object, apply the additionalFields fields that don't reside inside the schema
if type.based["DynamicSerializable"] != nil {
%>
doc += self.additionalFields
<% } %>

<%
// Loops over all variables in this Model/Embeddable and serializes them to the output document
for variable in type.allVariables where variable.name != "id" {
// If it's an array of Primitive types
if variable.isArray, let elementType = variable.type?.name, supportedPrimitives.contains(elementType) {
%>
doc["<%= variable.name %>"] = self.<%= variable.name %>
<%} else if variable.isArray, variable.typeName.array?.elementType?.based["Embeddable"] != nil {%>
doc["<%= variable.name %>"] = self.<%= variable.name %>
// If it's an array of references
<%} else if variable.isArray, variable.typeName.array?.elementType?.name == "Reference" {%>
doc["<%= variable.name %>"] = self.<%= variable.name %><% if variable.typeName.isOptional { %>?<% } %>.map { $0.id }
<%     } else if supportedPrimitives.contains(variable.typeName.unwrappedTypeName) {%>
doc["<%= variable.name %>"] = self.<%= variable.name %>
<%
// If this is a single reference
} else if variable.typeName.name.hasPrefix("Reference") {%>
if resolvingReferences {
doc["<%= variable.name %>"] = doc["<%= variable.name %>"] = try self.<%= variable.name %><% if variable.typeName.isOptional { %>?<% } %>.resolve().meowSerialize()
} else {
doc["<%= variable.name %>"] = self.<%= variable.name %><% if variable.typeName.isOptional { %>?<% } %>.id
}
} else if variable.type?.based["Embeddable"] != nil { %>
doc["<%= variable.name %>"] = self.<%= variable.name %><% if variable.typeName.isOptional { %>?<% } %>.meowSerialize()
<%
} else {
%>
// <%= variable %>
<%
}
}%>

return doc
}

<%
// Creates a new instance of this model/embeddable from a Document
%>
convenience init(fromDocument source: Document) throws {
var source = source
// Extract all properties
<% usedNames = [] %>
<% for variable in type.variables where !usedNames.contains(variable.name) { %>
<% usedNames.append(variable.name) %>
<% if variable.isArray, let elementType = variable.typeName.array?.elementTypeName.name, supportedPrimitives.contains(elementType) { %>
// The property is a BSON type, so we can just extract it from the document:
<% if variable.typeName.isOptional { %>
let <%=variable.name%>Value: <%=variable.typeName%> = <%=variable.typeName.unwrappedTypeName%>(source.removeValue(forKey: "<%=variable.name%>"))
<% } else { %>
let <%=variable.name%>Value: <%=variable.typeName%> = try Meow.Helpers.requireValue(<%=variable.typeName%>(source.removeValue(forKey: "<%=variable.name%>")), keyForError: "<%=variable.name%>")
<% } %>
<%} else if variable.isArray, variable.typeName.array?.elementTypeName.name == "Reference" {%>
// o the noes it is a reference
let <%=variable.name%>Ids = try Meow.Helpers.requireValue(source.removeValue(forKey: "<%=variable.name%>") as? Document, keyForError: "<%=variable.name%>").arrayValue
let <%=variable.name%>Value: <%=variable.typeName%>

<% if variable.typeName.isOptional { %>
if let <%=variable.name%>Ids = <%=variable.name%>Ids {
<%=variable.name%>Value = try <%=variable.name%>Ids.map { try Meow.Helpers.requireValue(ObjectId($0), keyForError: "<%=variable.name%>") }
} else {
<%=variable.name%>Value = nil
}
<% } else { %>
<%=variable.name%>Value = try <%=variable.name%>Ids.map {
Reference(restoring: try Meow.Helpers.requireValue(ObjectId($0), keyForError: "<%=variable.name%>"))
}
<% } %>
<%} else if variable.isArray, let subType = variable.typeName.array?.elementType, subType.based["Embeddable"] != nil { %>
// TODO: Optionals
let <%= variable.name%>PrimitiveValues = try Meow.Helpers.requireValue(Document(source.removeValue(forKey: "<%=variable.name%>")), keyForError: "<%=variable.name%>").arrayValue
let <%=variable.name%>Value: <%=variable.typeName%> = try <%=variable.name%>PrimitiveValues.map {
try <%= subType.name %>(value: $0)
}
<% } else { %>
<% if supportedPrimitives.contains(variable.typeName.unwrappedTypeName) { %>
// The property is a BSON type, so we can just extract it from the document:
<% if variable.typeName.isOptional { %>
let <%=variable.name%>Value: <%=variable.typeName%> = <%=variable.typeName.unwrappedTypeName%>(source.removeValue(forKey: "<%=variable.name%>"))
<% } else { %>
let <%=variable.name%>Value: <%=variable.typeName%> = try Meow.Helpers.requireValue(<%=variable.typeName%>(source.removeValue(forKey: "<%=variable.name%>")), keyForError: "<%=variable.name%>")
<% } %>
<% } else if variable.typeName.name.hasPrefix("Reference") { %>
// o the noes it is a reference
let <%=variable.name%>Id: ObjectId? = source.removeValue(forKey: "<%=variable.name%>") as? ObjectId
let <%=variable.name%>Value: <%=variable.typeName%>

<% if variable.typeName.isOptional { %>
if let <%=variable.name%>Id = <%=variable.name%>Id {
<%=variable.name%>Value = Reference(restoring: <%=variable.name%>Id)
} else {
<%=variable.name%>Value = nil
}
<% } else { %>
<%=variable.name%>Value = Reference(restoring: try Meow.Helpers.requireValue(<%=variable.name%>Id, keyForError: "<%=variable.name%>"))
<% } %>
<% } else if variable.type?.based["Embeddable"] != nil { %>
<% if variable.typeName.isOptional { %>
let <%=variable.name%>Value: <%=variable.typeName%>
<% if variable.type?.kind == "enum" { %>
if let sourceVal = source.removeValue(forKey: "<%=variable.name%>") {
<%=variable.name%>Value = try <%=variable.typeName.unwrappedTypeName%>(value: sourceVal)
} else {
<%=variable.name%>Value = nil
}
<% } else { %>

if let <%=variable.name%>Document: Document = source.removeValue(forKey: "<%=variable.name%>") as? Document {
<%=variable.name%>Value = try <%=variable.typeName.unwrappedTypeName%>(fromDocument: <%=variable.name%>Document)
} else {
<%=variable.name%>Value = nil
}
<% } %>
<% } else { %>
<% if variable.type?.kind == "enum" { %>
let <%=variable.typeName%>Val = try Meow.Helpers.requireValue(source.removeValue(forKey: "<%=variable.name%>"), keyForError: "<%=variable.name%>")
let <%=variable.name%>Value: <%=variable.typeName%> = try <%=variable.typeName%>(value: <%=variable.typeName%>Val)
<% } else { %>
let <%=variable.name%>Document: Document = try Meow.Helpers.requireValue(source.removeValue(forKey: "<%=variable.name%>") as? Document, keyForError: "<%=variable.name%>")
let <%=variable.name%>Value: <%=variable.typeName%> = try <%=variable.typeName%>(fromDocument: <%=variable.name%>Document)
<% } %>
<% } %>
<% } else if variable.name == "id" { %>
let idValue: ObjectId = try Meow.Helpers.requireValue(source.removeValue(forKey: "_id") as? ObjectId, keyForError: "id")
<% } %>
<% } %>
<% } %>

// Uses the first existing initializer
// TODO: Support multiple/more complex initializers
try self.init(
<% let parameters = type.initializers.first?.parameters ?? [] %>
<% for (index, parameter) in parameters.enumerated() { %>
<%= parameter.argumentLabel! %>: <%= parameter.name%>Value
<% if parameters.count != index+1 { %>
,
<% } %>
<% } %>
)

// Sets the other variables
<% usedNames = [] %>
<% for variable in type.variables where !usedNames.contains(variable.name) { %>
<% usedNames.append(variable.name) %>
<% if type.based["DynamicSerializable"] != nil && variable.name == "additionalFields" { %>
self.additionalFields = source
<% } else { %>
self.<%=variable.name%> = <%=variable.name%>Value
<% } %>
<% } %>
}

<%
// The VirtualInstance of this type. Part of the type safe query language
%>
struct VirtualInstance {
var keyPrefix: String

<% usedNames = [] %>
<% for variable in type.variables where !usedNames.contains(variable.name) { %>
<% usedNames.append(variable.name) %>
// <%=variable.name%>: <%=variable.typeName%>
<% if variable.typeName.unwrappedTypeName == "String"
|| variable.typeName.unwrappedTypeName == "ObjectId"
|| variable.typeName.unwrappedTypeName == "Date"
|| variable.typeName.unwrappedTypeName == "Data"
|| variable.typeName.unwrappedTypeName == "Bool" { %>
var <%= variable.name %>: Virtual<%=variable.unwrappedTypeName%> { return Virtual<%=variable.unwrappedTypeName%>(name: keyPrefix + "<%=variable.name%>") }
<% } else if variable.typeName.unwrappedTypeName == "[String]"
|| variable.typeName.unwrappedTypeName == "[ObjectId]"
|| variable.typeName.unwrappedTypeName == "[Date]"
|| variable.typeName.unwrappedTypeName == "[Data]"
|| variable.typeName.unwrappedTypeName == "[Bool]" { %>
var <%= variable.name %>: VirtualArray<Virtual<%=variable.unwrappedTypeName%>> { return VirtualArray<Virtual<%=variable.unwrappedTypeName%>>(name: keyPrefix + "<%=variable.name%>") }
<% } else if variable.typeName.unwrappedTypeName == "Int"
|| variable.typeName.unwrappedTypeName == "Int32"
|| variable.typeName.unwrappedTypeName == "Int64"
|| variable.typeName.unwrappedTypeName == "Double" { %>
var <%= variable.name %>: VirtualNumber { return VirtualNumber(name: keyPrefix + "<%=variable.name%>") }
<% } else if variable.typeName.unwrappedTypeName == "[Int]"
|| variable.typeName.unwrappedTypeName == "[Int32]"
|| variable.typeName.unwrappedTypeName == "[Int64]"
|| variable.typeName.unwrappedTypeName == "[Double]" { %>
var <%= variable.name %>: VirtualArray<VirtualNumber> { return VirtualArray<VirtualNumber>(name: keyPrefix + "<%=variable.name%>") }
<% } else if variable.typeName.name.hasPrefix("Reference") { %>
var <%= variable.name %>: VirtualReference<<%=variable.typeName.unwrappedTypeName%>.Model, <%=variable.typeName.unwrappedTypeName%>.DeleteRule> { return VirtualReference(name: keyPrefix + "<%=variable.name%>") }
<% } else if variable.typeName.name.hasPrefix("[Reference") { %>
var <%= variable.name %>: VirtualReferenceArray<<%=variable.typeName.unwrappedTypeName.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "") %>.Model, <%=variable.typeName.unwrappedTypeName.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "")%>.DeleteRule> { return VirtualReferenceArray<<%=variable.typeName.unwrappedTypeName.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "") %>.Model, <%=variable.typeName.unwrappedTypeName.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "")%>.DeleteRule>(name: keyPrefix + "<%=variable.name%>") }
<% } else if variable.type?.based["Embeddable"] != nil { %>
var <%=variable.name%>: <%=variable.typeName.unwrappedTypeName%>.VirtualInstance { return <%=variable.typeName.unwrappedTypeName%>.VirtualInstance(keyPrefix: "<%=variable.name%>.") }
<% } else { %>
// <%=variable%>
<% } %>
<% } %>

init(keyPrefix: String = "") {
self.keyPrefix = keyPrefix
}
}

<%
// Keeps track of all references in this model
// Used for applying delete rules on references
%>
var meowReferencesWithValue: [(key: String, destinationType: ConcreteModel.Type, deleteRule: DeleteRule.Type, id: ObjectId)] {
var result = [(key: String, destinationType: ConcreteModel.Type, deleteRule: DeleteRule.Type, id: ObjectId)]()
_ = result.popLast() // to silence the warning of not mutating above variable in the case of a type with no references

<% for variable in type.variables { %>
<% if variable.typeName.name.hasPrefix("Reference") { %>
<% if variable.isOptional { %>
if let <%=variable.name%>Value = self.<%=variable.name%> {
<% } else { %>
let <%=variable.name%>Value = self.<%=variable.name%>
<% } %>
result.append(("<%=variable.name%>", <%=variable.name%>Value.destinationType, <%=variable.name%>Value.deleteRule, <%=variable.name%>Value.id))
<% if variable.isOptional { %>
}
<% } %>
<% } %>
<% } %>

return result
}
}
<% } %>


<%
// For each model, generate a type safe query language and helpers for Vapor
for type in types.based["Model"] ?? [] {
%>
extension <%= type.name %> : ConcreteModel {
static let meowCollection = Meow.database["<%= type.name.lowercased() %>"]

static func find(_ closure: ((VirtualInstance) -> (Query))) throws -> Cursor<<%= type.name %>> {
let query = closure(VirtualInstance())
return try self.find(query)
}

static func findOne(_ closure: ((VirtualInstance) -> (Query))) throws -> <%= type.name %>? {
let query = closure(VirtualInstance())
return try self.findOne(query)
}

static func count(_ closure: ((VirtualInstance) -> (Query))) throws -> Int {
let query = closure(VirtualInstance())
return try self.count(query)
}

static func createIndex(named name: String? = nil, withParameters closure: ((VirtualInstance, IndexSubject) -> ())) throws {
let indexSubject = IndexSubject()
closure(VirtualInstance(), indexSubject)

try meowCollection.createIndexes([(name: name ?? "", parameters: indexSubject.makeIndexParameters())])
}
}

<%
// Makes this model initializable by a String representing an ObjectId
%>
extension <%= type.name %> : StringInitializable {
public convenience init?(from string: String) throws {
guard let document = try <%= type.name %>.meowCollection.findOne("_id" == (try ObjectId(string))) else {
return nil
}

try self.init(fromDocument: document)
}
}

<%
// Makes this model Primitive so that it can be expressed as ExtendedJSON
%>
//   extension <%= type.name %> : Primitive {
//     public var typeIdentifier: UInt8 {
//       return 0x03
//     }
//
//     public func makeBinary() -> [UInt8] {
//       return self.meowSerialize().makeBinary()
//     }
//   }
//
//   extension <%= type.name %> : ResponseRepresentable {
//     public func makeResponse() -> Response {
//       return self.makeExtendedJSON().makeResponse()
//     }
//   }
// <% } %>








<%
// Adds helpers for Vapor's Droplet
// Generates routes based on your sourcery comments in models
%>
// extension Droplet {
//   public func start(_ mongoURL: String) throws -> Never {
//     let meow = try Meow.init(mongoURL)
//
//     <% for type in (types.based["Model"] ?? []) { %>
//       <% for method in type.methods where method.accessLevel == "public" || method.accessLevel == "internal" && method.annotations["api"] != nil { %>
//         <% if method.isStatic { %>
//           self.<%= (method.annotations["api"] as? String ?? "").lowercased() %>("<%= type.name.lowercased() %>s", "<%= method.annotations["pathSuffix"] as? String ?? method.shortName %>") { request in
//         <% } else { %>
//           self.<%= (method.annotations["api"] as? String ?? "").lowercased() %>("<%= type.name.lowercased() %>s", <%= type.name %>.self, "<%= method.annotations["pathSuffix"] as? String ?? method.shortName %>") { request, model in
//         <% } %>
//
//         <% if (method.annotations["data"] as? String ?? "").lowercased() == "query" || (method.annotations["data"] as? String ?? "").lowercased() == "json" { %>
//           <% if (method.annotations["data"] as? String ?? "").lowercased() == "query" { %>
//             guard let query = request.query, case .object(let parameters) = query else {
//                 return Response(status: .badRequest)
//             }
//           <% } else { %>
//             guard let json = request.json?.node, case .object(let parameters) = json else {
//                 return Response(status: .badRequest)
//             }
//           <% } %>
//
//           <% for parameter in method.parameters { %>
//             <% if parameter.typeName.isOptional {%>
//               <% if parameter.typeName.unwrappedTypeName == "String" { %>
//                 let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.string
//               <% } else if parameter.typeName.unwrappedTypeName == "Int" { %>
//                 let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.int
//               <% } else if parameter.typeName.unwrappedTypeName == "Bool" { %>
//                 let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.bool
//               <% } else if parameter.typeName.unwrappedTypeName == "Float" { %>
//                 let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.float
//               <% } else if parameter.typeName.unwrappedTypeName == "Double" { %>
//                 let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.double
//               <% } else if parameter.typeName.unwrappedTypeName == "ObjectId" { %>
//                 let <%= parameter.name %> = try? ObjectId(parameters["<%= parameter.name %>"]?.string ?? "")
//               <% } else { %>
//                 return Response(status: .internalServerError)
//               <% } %>
//
//             <% } else { %>
//
//               <% if parameter.typeName.unwrappedTypeName == "String" { %>
//                 guard let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.string else {
//                   return Response(status: .badRequest)
//                 }
//               <% } else if parameter.typeName.unwrappedTypeName == "Int" { %>
//                 guard let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.int else {
//                   return Response(status: .badRequest)
//                 }
//               <% } else if parameter.typeName.unwrappedTypeName == "Bool" { %>
//                 guard let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.bool else {
//                   return Response(status: .badRequest)
//                 }
//               <% } else if parameter.typeName.unwrappedTypeName == "Float" { %>
//                 guard let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.float else {
//                   return Response(status: .badRequest)
//                 }
//               <% } else if parameter.typeName.unwrappedTypeName == "Double" { %>
//                 guard let <%= parameter.name %> = parameters["<%= parameter.name %>"]?.double else {
//                   return Response(status: .badRequest)
//                 }
//               <% } else if parameter.typeName.unwrappedTypeName == "ObjectId" { %>
//                 guard let <%= parameter.name %>P = parameters["<%= parameter.name %>"]?.string, let <%= parameter.name %> = try ObjectId(<%= parameter.name %>P) else {
//                   return Response(status: .badRequest)
//                 }
//               <% } else { %>
//                 return Response(status: .internalServerError)
//               <% } %>
//             <% } %>
//           <% } %>
//         <% } %>
//
//         <% if (method.annotations["data"] as? String ?? "").lowercased() == "form" { %>
//           guard let parameters = request.multipart else {
//               return Response(status: .badRequest)
//           }
//
//           <% for parameter in method.parameters { %>
//             <% if parameter.typeName.isOptional {%>
//               <% if parameter.typeName.unwrappedTypeName == "String" { %>
//               let <%= parameter.name %>: String?
//                 if case .input(let <%= parameter.name %>P) = parameters["<%= parameter.name %>"] {
//                   <%= parameter.name %> = <%= parameter.name %>P
//                 } else {
//                 <%= parameter.name %> = nil
//                 }
//               <% } else if parameter.typeName.unwrappedTypeName == "Int" { %>
//               guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
//                 return Response(status: .badRequest)
//               }
//
//               let <%= parameter.name %> = Int(<%= parameter.name %>P)
//               <% } else if parameter.typeName.unwrappedTypeName == "Bool" { %>
//                 guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
//                   return Response(status: .badRequest)
//                 }
//
//                 let <%= parameter.name %> = (<%= parameter.name %>P.lowercased() == "true" || <%= parameter.name %>P.lowercased() == "1")
//               <% } else if parameter.typeName.unwrappedTypeName == "Float" { %>
//                 guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
//                   return Response(status: .badRequest)
//                 }
//
//                 let <%= parameter.name %> = Float(<%= parameter.name %>P)
//               <% } else if parameter.typeName.unwrappedTypeName == "Double" { %>
//                 guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
//                   return Response(status: .badRequest)
//                 }
//
//                 let <%= parameter.name %> = Double(<%= parameter.name %>P)
//               <% } else if parameter.typeName.unwrappedTypeName == "ObjectId" { %>
//                 guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
//                   return Response(status: .badRequest)
//                 }
//
//                 let <%= parameter.name %> = try? ObjectId(<%= parameter.name %>P)
//               <% } else { %>
//                 return Response(status: .internalServerError)
//               <% } %>
//
//             <% } else { %>
//               <% if parameter.typeName.unwrappedTypeName == "String" { %>
//                 guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>) = <%= parameter.name %>E else {
//                   return Response(status: .badRequest)
//                 }
//               <% } else if parameter.typeName.unwrappedTypeName == "Int" { %>
//               guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
//                 return Response(status: .badRequest)
//               }
//
//               let <%= parameter.name %> = Int(<%= parameter.name %>P)
//               <% } else if parameter.typeName.unwrappedTypeName == "Bool" { %>
//                 guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
//                   return Response(status: .badRequest)
//                 }
//
//                 let <%= parameter.name %> = (<%= parameter.name %>P.lowercased() == "true" || <%= parameter.name %>P.lowercased() == "1")
//               <% } else if parameter.typeName.unwrappedTypeName == "Float" { %>
//                 guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
//                   return Response(status: .badRequest)
//                 }
//
//                 let <%= parameter.name %> = Float(<%= parameter.name %>P)
//               <% } else if parameter.typeName.unwrappedTypeName == "Double" { %>
//                 guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
//                   return Response(status: .badRequest)
//                 }
//
//                 let <%= parameter.name %> = Double(<%= parameter.name %>P)
//               <% } else if parameter.typeName.unwrappedTypeName == "ObjectId" { %>
//                 guard let <%= parameter.name %>E = parameters["<%= parameter.name %>"], case .input(let <%= parameter.name %>P) = <%= parameter.name %>E else {
//                   return Response(status: .badRequest)
//                 }
//
//                 let <%= parameter.name %> = try ObjectId(<%= parameter.name %>P)
//               <% } else { %>
//                 return Response(status: .internalServerError)
//               <% } %>
//             <% } %>
//           <% } %>
//         <% } %>
//
//         <% if method.isStatic { %>
//         // TODO: Reverse isVoid when that works
//           <% if !method.returnTypeName.isVoid { %> let responseObject = <% } %>try <%= type.name %>.<%= method.shortName %>(
//             <% for (index, parameter) in method.parameters.enumerated() { %>
//               <%= parameter.name %>: <%= parameter.name %>
//               <% if method.parameters.count != index+1 { %>
//               ,
//               <% } %>
//             <% } %>
//           )
//
//           <% if method.returnType?.based["Model"] != nil { %>
//             <% if method.returnTypeName.isOptional == true { %>
//               return try Meow.Helpers.requireValue(responseObject, keyForError: "")
//             <% } else { %>
//               return responseObject
//             <% } %>
//           <% } else if method.returnTypeName.name.hasPrefix("Cursor<") { %>
//             <% if method.returnTypeName.isOptional == true { %>
//               return try Meow.Helpers.requireValue(responseObject, keyForError: "")
//             <% } else { %>
//               return responseObject
//             <% } %>
//           <% } else { %>
//             return Response(status: .ok)
//           <% } %>
//         <% } else { %>
//         // TODO: Reverse isVoid when that works
//           <% if !method.returnTypeName.isVoid { %> let responseObject = <% } %> try model.<%= method.shortName %>(
//             <% for (index, parameter) in method.parameters.enumerated() { %>
//               <%= parameter.name %>: <%= parameter.name %>
//               <% if method.parameters.count != index+1 { %>
//               ,
//               <% } %>
//             <% } %>
//           )
//
//             <% if method.returnType?.based["Model"] != nil { %>
//               return responseObject
//             <% } else if method.returnType?.based["Embeddable"] != nil { %>
//               return responseObject
//             <% } else if method.returnTypeName.name.hasPrefix("Cursor<") { %>
//               return responseObject
//             <% } else { %>
//               return Response(status: .ok)
//             <% } %>
//           <% } %>
//           }
//       <% } %>
//     <% } %>
//     self.run()
//   }
// }
